{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Brev Brev is a developer environment that: Automatically sets up your machine Instantly deploys your code Gives you unlimited resources Getting Started With Brev To get started with Brev, create an account at console.brev.dev Build something great :)","title":"Welcome to Brev"},{"location":"#welcome-to-brev","text":"Brev is a developer environment that: Automatically sets up your machine Instantly deploys your code Gives you unlimited resources","title":"Welcome to Brev"},{"location":"#getting-started-with-brev","text":"To get started with Brev, create an account at console.brev.dev Build something great :)","title":"Getting Started With Brev"},{"location":"howto/","text":"How To Find your localhost Looking for your localhost url? Make a Port Public Remove auth from your localhost Common Installations Cheatsheet for common installations, such as golang, node, python, etc.","title":"Home"},{"location":"howto/#how-to","text":"","title":"How To"},{"location":"howto/#find-your-localhost","text":"Looking for your localhost url?","title":"Find your localhost"},{"location":"howto/#make-a-port-public","text":"Remove auth from your localhost","title":"Make a Port Public"},{"location":"howto/#common-installations","text":"Cheatsheet for common installations, such as golang, node, python, etc.","title":"Common Installations"},{"location":"howto/common-installations/","text":"How To #3 Common Installations See below for common installations to put in your .brev/setup.sh script Install Node/NPM # note this installs node v14 curl -fsSL https://deb.nodesource.com/setup_14.x | sudo -E bash - sudo apt-get install -y nodejs Install Python, Pip, Poetry # install python sudo apt-get install -y python3-distutils sudo apt-get install -y python3-apt # install pip curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py python3 get-pip.py rm get-pip.py # this should go in your bashrc/zshrc too export PATH = \" $PATH :/home/brev/.local/bin\" # install poetry curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python3 - source $HOME /.poetry/env Install Node/NPM # note this installs node v14 curl -fsSL https://deb.nodesource.com/setup_14.x | sudo -E bash - sudo apt-get install -y nodejs Install Node/NPM # note this installs node v14 curl -fsSL https://deb.nodesource.com/setup_14.x | sudo -E bash - sudo apt-get install -y nodejs Install Basic Linux Utilities sudo apt-get install -y build-essential Install Zsh and Oh My Zsh # note: we recommend putting this in your personal .brev, not the repo .brev # Go to Account in the console to update your .brev sudo apt-get install zsh -y sh -c \" $( curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh ) \" \"\" --unattended echo \"zsh\" >> ~/.bashrc Install VS Code Extensions For the terminal command to install a VS Code extension, you'll need the highlighted ID, see below: Use the following ID in the line below: code-server --install-extension <HIGHLIGHTED_ID>","title":"Common Installations"},{"location":"howto/common-installations/#how-to-3","text":"","title":"How To #3"},{"location":"howto/common-installations/#common-installations","text":"See below for common installations to put in your .brev/setup.sh script Install Node/NPM # note this installs node v14 curl -fsSL https://deb.nodesource.com/setup_14.x | sudo -E bash - sudo apt-get install -y nodejs Install Python, Pip, Poetry # install python sudo apt-get install -y python3-distutils sudo apt-get install -y python3-apt # install pip curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py python3 get-pip.py rm get-pip.py # this should go in your bashrc/zshrc too export PATH = \" $PATH :/home/brev/.local/bin\" # install poetry curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python3 - source $HOME /.poetry/env Install Node/NPM # note this installs node v14 curl -fsSL https://deb.nodesource.com/setup_14.x | sudo -E bash - sudo apt-get install -y nodejs Install Node/NPM # note this installs node v14 curl -fsSL https://deb.nodesource.com/setup_14.x | sudo -E bash - sudo apt-get install -y nodejs Install Basic Linux Utilities sudo apt-get install -y build-essential Install Zsh and Oh My Zsh # note: we recommend putting this in your personal .brev, not the repo .brev # Go to Account in the console to update your .brev sudo apt-get install zsh -y sh -c \" $( curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh ) \" \"\" --unattended echo \"zsh\" >> ~/.bashrc Install VS Code Extensions For the terminal command to install a VS Code extension, you'll need the highlighted ID, see below: Use the following ID in the line below: code-server --install-extension <HIGHLIGHTED_ID>","title":"Common Installations"},{"location":"howto/find-my-localhost/","text":"How To #1 Find my localhost If you're inside your Brev workspace and are running something on localhost, you can access it using your workspace URL. From the dashboard, copy your url: Prefix the url with your port number + \"-\" and that's your url! For example: If your workspace url is jelly-brevdev.brev.sh and you're running on localhost:3000 your localhost url is 3000-jelly-brevdev.brev.sh .","title":"Find Your Localhost"},{"location":"howto/find-my-localhost/#how-to-1","text":"","title":"How To #1"},{"location":"howto/find-my-localhost/#find-my-localhost","text":"If you're inside your Brev workspace and are running something on localhost, you can access it using your workspace URL. From the dashboard, copy your url: Prefix the url with your port number + \"-\" and that's your url! For example: If your workspace url is jelly-brevdev.brev.sh and you're running on localhost:3000 your localhost url is 3000-jelly-brevdev.brev.sh .","title":"Find my localhost"},{"location":"howto/make-port-public/","text":"How To #2 Make a port public If you're accessing your localhost url such as 3000-jelly-brevdev.brev.sh , you'll notice it requires your password. If you want to remove auth to use Postman, consume the endpoint in your frontend, or just show your mom what you built, you can do so in the .brev/ports.yaml added to every Brev workspace. Add the port you wish to expose in the list and that's it! Note: the version field is optional. It could be useful if you choose to commit this to your project repo.","title":"Make a Port Public"},{"location":"howto/make-port-public/#how-to-2","text":"","title":"How To #2"},{"location":"howto/make-port-public/#make-a-port-public","text":"If you're accessing your localhost url such as 3000-jelly-brevdev.brev.sh , you'll notice it requires your password. If you want to remove auth to use Postman, consume the endpoint in your frontend, or just show your mom what you built, you can do so in the .brev/ports.yaml added to every Brev workspace. Add the port you wish to expose in the list and that's it! Note: the version field is optional. It could be useful if you choose to commit this to your project repo.","title":"Make a port public"},{"location":"reference/","text":"Reference Brev creates your powerful computer in the cloud for development. Everything has moved to the cloud except your development, which doesn't make a ton of sense since development has the most to benefit from the cloud: unlimited ram and CPU instant upgrades to the latest and greatest hardware no more wasting time with machine configurations get a public url for anything you're working on: APIs, front ends, etc. Brev is not a streamed computer-- it's a service that configures your powerful cloud computer for you to build anything with. You are the superuser on your Brev machine. The .brev directory Brev solves configurations with the .brev directory. There are two types of configurations: Personal dev configs, such as Zsh vs Bash, light mode vs dark mode, keybindings, and certain extensions Repo configs, such as node version, python version, any specific installation/set up/onboarding instructions. Personal .brev For the first type of configs, go to your Account and update the Workspace Settings Repo. You'll need a git repo that just contains a .brev/setup.sh file. Fork this repo as a good place to start. Project .brev Automatically configure your project for any new contributor by commiting a .brev/setup.sh to the code repository. Brev will automatically execute the script for every new workspace created. Brev automatically creates the .brev/setup.sh if it doesn't exist.","title":"Home"},{"location":"reference/#reference","text":"Brev creates your powerful computer in the cloud for development. Everything has moved to the cloud except your development, which doesn't make a ton of sense since development has the most to benefit from the cloud: unlimited ram and CPU instant upgrades to the latest and greatest hardware no more wasting time with machine configurations get a public url for anything you're working on: APIs, front ends, etc. Brev is not a streamed computer-- it's a service that configures your powerful cloud computer for you to build anything with. You are the superuser on your Brev machine.","title":"Reference"},{"location":"reference/#the-brev-directory","text":"Brev solves configurations with the .brev directory. There are two types of configurations: Personal dev configs, such as Zsh vs Bash, light mode vs dark mode, keybindings, and certain extensions Repo configs, such as node version, python version, any specific installation/set up/onboarding instructions.","title":"The .brev directory"},{"location":"reference/#personal-brev","text":"For the first type of configs, go to your Account and update the Workspace Settings Repo. You'll need a git repo that just contains a .brev/setup.sh file. Fork this repo as a good place to start.","title":"Personal .brev"},{"location":"reference/#project-brev","text":"Automatically configure your project for any new contributor by commiting a .brev/setup.sh to the code repository. Brev will automatically execute the script for every new workspace created. Brev automatically creates the .brev/setup.sh if it doesn't exist.","title":"Project .brev"},{"location":"tutorials/","text":"Tutorials Tutorial 1: Make a backend for a todo list app. Create tasks, get your tasks, and update them.","title":"Home"},{"location":"tutorials/#tutorials","text":"","title":"Tutorials"},{"location":"tutorials/#tutorial-1-make-a-backend-for-a-todo-list-app","text":"Create tasks, get your tasks, and update them.","title":"Tutorial 1: Make a backend for a todo list app."},{"location":"tutorials/to-do-app-backend-tutorial/","text":"Tutorial #1 Make a backend for a todo list app. Create tasks, get your tasks, and update them. This tutorial will walk you through creating 3 APIs on Brev, hooked up to a database to store everything. If you find yourself stuck, wanna brainstorm anything, or just wanna chat, text us: 415-818-0207 The basic design: - GET request to fetch all remaining todos - POST request to create new todos - PUT request to update a todo as completed 1: Create a new project note: you can skip this step if you want to use an existing Brev project Create a folder for this project. Go to that directory in your terminal, and initialize a Brev project. brev init 2: Create the endpoint In the directory of your brev project, create a new endpoint. We named it todos but you can name it however you like. brev endpoint add --name todos By default, everything with Brev is hosted and deployed for you! Run the below command to see the endpoint URLs. brev endpoint list Copy the URL and open it in a new tab with your web browser! You should see an empty response {} Edit the endpoint file with your preferred code editor. You'll see a basic function called get . This is the function that gets called when the URL is hit via an HTTP GET request. 3 Test the instantaneous deploy Change the return of the def get() function, save the file, and refresh the URL in your browser tab. Everything is immediately available! 4 Create new tasks We need to accept tasks to our function. We can send the tasks to our endpoint as JSON. Since Brev is built on top of FastAPI, we can leverage Pydantic BaseModel classes to represent our data. In the same file, above your post function, represent your JSON data as a BaseModel class: from pydantic import BaseModel class ToDo ( BaseModel ): task : str status : str Now that we've defined what a todo looks like, we just need to pass it in to our function. We should use a POST request since we're creating new data, so just create a new function called post in our endpoint file. from pydantic import BaseModel class ToDo ( BaseModel ): task : str status : str def post (): return {} Brev will automatically call the post function when the URL is hit with a POST request. Brev endpoint files are the entry points to your project. To create a ToDo, simply pass in an instance of type ToDo . from pydantic import BaseModel class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo ): return {} Data validation happens automatically! So if your endpoint is called with JSON that doesn't include the status field, it'll return a 403 data validation error. You can comfortably expect your code to only execute if the required parameters are passed in. Test it out! Run your endpoint using an app like Postman, the Brev console, or your terminal! Via the Brev CLI: brev endpoint run --name todo --method POST --body '{\"task\":\"Brev Tutorial 1\", \"status\": \"incomplete\"}' 5 Save the tasks in a database Brev comes with a database out of the box. Simply import it to use it! from global_storage import storage_context from pydantic import BaseModel class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo , db = storage_context ( \"todos\" )): return {} We're passing an instance of the database to the post function. By giving it the context name \"todos\", Brev will look for the database table named todos , or create it if it doesn't exist -- no initialization needed! :) Now that we have a database set up, let's store the todos, and return a useful message. from global_storage import storage_context from pydantic import BaseModel import uuid class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo , db = storage_context ( \"todos\" )): db [ uuid . uuid4 ()] = todo # save the todo return { \"success\" : f \"Successfully saved task { todo . task } \" } From the Brev dev console, go to the storage viewer to see your database items! 6 Get your active todos Storing is no fun if we can't access everything. Create a GET request that returns your active todos, first passing the database context to your get function. from global_storage import storage_context from pydantic import BaseModel import uuid class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo , db = storage_context ( \"todos\" )): db [ uuid . uuid4 ()] = todo # save the todo return { \"success\" : f \"Successfully saved task { todo . task } \" } def get ( db = storage_context ( \"todos\" )): pending_todos = [ todo for todo in db . values () if todo . status == \"pending\" ] return { \"result\" : pending_todos } 7 The final step is to create an endpoint to modify We want to edit a specific ToDo and mark it as completed. Given a todo ID, we can make a PUT request to change it's state. Add a function for a put request that accepts the ID as a query parameter. (Don't forget to pass the db in as well ) from global_storage import storage_context from pydantic import BaseModel import uuid class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo , db = storage_context ( \"todos\" )): db [ uuid . uuid4 ()] = todo # save the todo return { \"success\" : f \"Successfully saved task { todo . task } \" } def get ( db = storage_context ( \"todos\" )): pending_todos = [ todo for todo in db . values () if todo . status == \"pending\" ] return { \"result\" : pending_todos } def put ( id , db = storage_context ( \"todos\" )): return {} The incoming data to a function can be a variety of types. Using a BaseModel type like we do for the POST request is what specifies incoming data as JSON. Final step is to just pop the associated id from global_storage import storage_context from pydantic import BaseModel import uuid class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo , db = storage_context ( \"todos\" )): db [ uuid . uuid4 ()] = todo # save the todo return { \"success\" : f \"Successfully saved task { todo . task } \" } def get ( db = storage_context ( \"todos\" )): pending_todos = [ todo for todo in db . values () if todo . status == \"pending\" ] return { \"result\" : pending_todos } def put ( id , db = storage_context ( \"todos\" )): db [ id ][ 'status' ] = \"completed\" return { \"result\" : } And there you have it! You now have everything you need to build out a ToDo app! Brev is meant to be configured to your specific use case. Further Reading How To: Best Practices for Brev DB","title":"Tutorial 1"},{"location":"tutorials/to-do-app-backend-tutorial/#tutorial-1","text":"","title":"Tutorial #1"},{"location":"tutorials/to-do-app-backend-tutorial/#make-a-backend-for-a-todo-list-app","text":"Create tasks, get your tasks, and update them. This tutorial will walk you through creating 3 APIs on Brev, hooked up to a database to store everything. If you find yourself stuck, wanna brainstorm anything, or just wanna chat, text us: 415-818-0207 The basic design: - GET request to fetch all remaining todos - POST request to create new todos - PUT request to update a todo as completed","title":"Make a backend for a todo list app."},{"location":"tutorials/to-do-app-backend-tutorial/#1-create-a-new-project","text":"note: you can skip this step if you want to use an existing Brev project Create a folder for this project. Go to that directory in your terminal, and initialize a Brev project. brev init","title":"1: Create a new project"},{"location":"tutorials/to-do-app-backend-tutorial/#2-create-the-endpoint","text":"In the directory of your brev project, create a new endpoint. We named it todos but you can name it however you like. brev endpoint add --name todos By default, everything with Brev is hosted and deployed for you! Run the below command to see the endpoint URLs. brev endpoint list Copy the URL and open it in a new tab with your web browser! You should see an empty response {} Edit the endpoint file with your preferred code editor. You'll see a basic function called get . This is the function that gets called when the URL is hit via an HTTP GET request.","title":"2: Create the endpoint"},{"location":"tutorials/to-do-app-backend-tutorial/#3-test-the-instantaneous-deploy","text":"Change the return of the def get() function, save the file, and refresh the URL in your browser tab. Everything is immediately available!","title":"3 Test the instantaneous deploy"},{"location":"tutorials/to-do-app-backend-tutorial/#4-create-new-tasks","text":"We need to accept tasks to our function. We can send the tasks to our endpoint as JSON. Since Brev is built on top of FastAPI, we can leverage Pydantic BaseModel classes to represent our data. In the same file, above your post function, represent your JSON data as a BaseModel class: from pydantic import BaseModel class ToDo ( BaseModel ): task : str status : str Now that we've defined what a todo looks like, we just need to pass it in to our function. We should use a POST request since we're creating new data, so just create a new function called post in our endpoint file. from pydantic import BaseModel class ToDo ( BaseModel ): task : str status : str def post (): return {} Brev will automatically call the post function when the URL is hit with a POST request. Brev endpoint files are the entry points to your project. To create a ToDo, simply pass in an instance of type ToDo . from pydantic import BaseModel class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo ): return {} Data validation happens automatically! So if your endpoint is called with JSON that doesn't include the status field, it'll return a 403 data validation error. You can comfortably expect your code to only execute if the required parameters are passed in. Test it out! Run your endpoint using an app like Postman, the Brev console, or your terminal! Via the Brev CLI: brev endpoint run --name todo --method POST --body '{\"task\":\"Brev Tutorial 1\", \"status\": \"incomplete\"}'","title":"4 Create new tasks"},{"location":"tutorials/to-do-app-backend-tutorial/#5-save-the-tasks-in-a-database","text":"Brev comes with a database out of the box. Simply import it to use it! from global_storage import storage_context from pydantic import BaseModel class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo , db = storage_context ( \"todos\" )): return {} We're passing an instance of the database to the post function. By giving it the context name \"todos\", Brev will look for the database table named todos , or create it if it doesn't exist -- no initialization needed! :) Now that we have a database set up, let's store the todos, and return a useful message. from global_storage import storage_context from pydantic import BaseModel import uuid class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo , db = storage_context ( \"todos\" )): db [ uuid . uuid4 ()] = todo # save the todo return { \"success\" : f \"Successfully saved task { todo . task } \" } From the Brev dev console, go to the storage viewer to see your database items!","title":"5 Save the tasks in a database"},{"location":"tutorials/to-do-app-backend-tutorial/#6-get-your-active-todos","text":"Storing is no fun if we can't access everything. Create a GET request that returns your active todos, first passing the database context to your get function. from global_storage import storage_context from pydantic import BaseModel import uuid class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo , db = storage_context ( \"todos\" )): db [ uuid . uuid4 ()] = todo # save the todo return { \"success\" : f \"Successfully saved task { todo . task } \" } def get ( db = storage_context ( \"todos\" )): pending_todos = [ todo for todo in db . values () if todo . status == \"pending\" ] return { \"result\" : pending_todos }","title":"6 Get your active todos"},{"location":"tutorials/to-do-app-backend-tutorial/#7-the-final-step-is-to-create-an-endpoint-to-modify","text":"We want to edit a specific ToDo and mark it as completed. Given a todo ID, we can make a PUT request to change it's state. Add a function for a put request that accepts the ID as a query parameter. (Don't forget to pass the db in as well ) from global_storage import storage_context from pydantic import BaseModel import uuid class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo , db = storage_context ( \"todos\" )): db [ uuid . uuid4 ()] = todo # save the todo return { \"success\" : f \"Successfully saved task { todo . task } \" } def get ( db = storage_context ( \"todos\" )): pending_todos = [ todo for todo in db . values () if todo . status == \"pending\" ] return { \"result\" : pending_todos } def put ( id , db = storage_context ( \"todos\" )): return {} The incoming data to a function can be a variety of types. Using a BaseModel type like we do for the POST request is what specifies incoming data as JSON. Final step is to just pop the associated id from global_storage import storage_context from pydantic import BaseModel import uuid class ToDo ( BaseModel ): task : str status : str def post ( todo : ToDo , db = storage_context ( \"todos\" )): db [ uuid . uuid4 ()] = todo # save the todo return { \"success\" : f \"Successfully saved task { todo . task } \" } def get ( db = storage_context ( \"todos\" )): pending_todos = [ todo for todo in db . values () if todo . status == \"pending\" ] return { \"result\" : pending_todos } def put ( id , db = storage_context ( \"todos\" )): db [ id ][ 'status' ] = \"completed\" return { \"result\" : } And there you have it! You now have everything you need to build out a ToDo app! Brev is meant to be configured to your specific use case.","title":"7 The final step is to create an endpoint to modify"},{"location":"tutorials/to-do-app-backend-tutorial/#further-reading","text":"How To: Best Practices for Brev DB","title":"Further Reading"}]}